# 블록체인 심화 DAY 4



## # Go-Ethereum

- Tip : vi 에서 : set number 하면 라인 번호.
- PDF 파일 참조 (Go언어 활용한 전자 지갑 개발 입문.)

---



## # Block  #4663025 (Uncle Block) 

- Uncle Block 참고하기 위한 좋은 예제 블록.

![1530839147775](C:\Users\Kchaos7\AppData\Local\Temp\1530839147775.png)



- ## # 엉클 블록과 고스트 프로토콜(다른 블록에 태움)

  1. ##### 블록생성에 성공함

     - 검증에 오류 X.

     - 이더리움 네트워크로 브로드 캐스팅.

     - 다른 채굴자가 생성한 블록에 비해 **난이도 낮아서** 최종 블록체인에 등록되지 못한 블록.

       >  동시에 블록이 생성되어 전파되는 경우, 난이도가 낮은  것은 블록에 등록되지 못하는 경우 발생.

       > **비트코인은 평균 10분 채굴**, **이더리움은 평균 1분 내로 채굴**됨. 이더리움 빠르기 때문에 만들어진 것이 낙오될 가능성 높아 엉클 블록이라는 개념을 따로 도입.

     - 엉클 블록이 많이 발생.

       > 트랜잭션 지연 발생.

       > 컴퓨팅 파워 낭비. 긴 체인에 등록되지 않으면 엉클블록, 또 다시 트랜잭션이 되므로 낭비.

       > 평균 블록 생성시간이 늘어나고, 난이도가 낮아지면 보안 문제 발생(Total Difficulty는 지금까지 누적된 난이도들의 합, 요소의 난이도가 전체적으로 낮아지게 되므로, 긴 체인이 많이 생기게 된다. 그 결과, 네트워크 트래픽에 영향을 미친다.) 및 다음 블록 난이도 증가.
       >
       > > #### 해결책 
       > >
       > > ##### 고스트프로토콜(다중 체인의 방지)
       > >
       > > > 블록 생성시 정상 블록에 최대 2개 까지 엉클 블록을 추가하고, 각 엉클 블록에 대해 보상, 최종적으로 합쳐짐.
       > > >
       > > > ![1530839247961](C:\Users\Kchaos7\AppData\Local\Temp\1530839247961.png)
       > > >
       > > > [positon 0's uncle reward 1**.**875 Ether + position 1's uncle reward 2.25 Ether = Uncles reward 4.125 Ether]
       > >
       > > ##### 엉클 블록은 처음에는 트랜잭션을 포함해서 블록생성
       > >
       > > > 마이너에 채택되지 않아서 엉클.
       > >
       > > > 트랜잭션 처리되지 않고(같은 시간에 블록이 두 개.)
       > >
       > > > 정상 블록 트랜잭션 처리, 엉클 블록은 트랙잭션 처리 X. 
       > > >
       > > > (트랜잭션 만들지 않았으니깐 블록은 만들지 않아도 됨.)



참고 : [Smart Contract 개발 #8 이더리움 핵심 개요 정리 2](https://steemkr.com/coinkorea/@etainclub/smart-contract-8-2)



## # 가스비

- Gas Used : 2,053,228 (30.62%)

  Gas Limit : 6,706,546

  - 트랜잭션에 대한 수수료.
    - 기본 단위 GWei = 1 ether = 1000000000 Gwei (10억)
  - Gas Used : 지불한 가격.
  - Gas Limit : 송금 작업에서 소비되는 가스량.
  - 블록가스 총량(Gas Limit) : 한 블록에 담을 수 있는 가스 총 량
    - 2017 - 6,700,000 
    - 2018 - 7,900,000
    - 개당 최소 처리 가스 비용 : 21,000
      - 최대 트랜잭션 처리 갯수는?  7,900,000 / 21000  = 376개

---

## # MetaMask #2

- 가스 가격 * 가스 한도 = 수수료
  - user 01 - 수수료 50
  - user 02 - 수수료 30
  - user 03 - 수수료 40
  - user 04 - 수수료 10
  - user 05 - 수수료 20
- 블록 가스 최대 Limit : 100
- 채굴자는 user01(50)+user01(40) 을 선택하여 최대한 100 안넘어 가는 큰 수를 만든다.

---

- Total Difficulty : 모든 블록의  난이도 누적 합계.

  - 포크의 경우 긴 체인을 결정 짓는 지표.

- Solidity -> 함수(sha = keccak256)

  - sha3(표준)
  - keccak256(sha3의 알고리즘을 개발한 팀, 공모전으로 NIST 제출.)
  - 즉, eher의 블록 요소 중 Sha3Uncles 는 keccak256 과 같다.

- sha3Uncles(keccak256 형식)

  : 현재 블록과 같은 시기에 생성한 엉클 블록 배열의 해시 값



```
> eth.getBlock(1160)
{
  difficulty: 203504,
  extraData: "0xd783010802846765746887676f312e392e34856c696e7578",
  gasLimit: 43212274,
  gasUsed: 0,
  hash: "0x7b1b1f5eac41edb8e0f6ea992f0960f17dc9d9544c89e5649c6475838d98acc2",
  logsBloom: "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
  miner: "0xd66715f4250d3a5b193739707462249cbdf28c4c",
  mixHash: "0x1f2b70d59c193c43a85f43e561b6122568af19f7ee4a866be9a7e534536d4262",
  nonce: "0x4b1257d6d89b2bd9",
  number: 1160,
  parentHash: "0xe887be8231059d758bbf7f7d00d3419829ae8b5ebacff85ed35011a02fc47ed2",
  receiptsRoot: "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421",
  sha3Uncles: "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347",
  size: 538,
  stateRoot: "0x69cef81af23a9e98cd88020cc30957445648d8a4faa67e458b6c6c9699d8edc8",
  timestamp: 1530774253,
  totalDifficulty: 190333180,
  transactions: [],
  transactionsRoot: "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421",
  uncles: []
}
```

- logBloom

  - 데이터 존재 유무 확인하기 위한 데이터 자료구조

  - 트랙잭션 목록

  -  해당 트랜잭션에서 생성된
      로그들의 중복 저장 방지.

    - 저장 공간 절약.

  - 만약, 트랜잭션을 넣게되면 00000 값이 1로 숫자가 바뀜

  - [블룸 필터(Bloom Filter)](https://ko.wikipedia.org/wiki/%EB%B8%94%EB%A3%B8_%ED%95%84%ED%84%B0)

     **블룸 필터**(Bloom filter)는 [원소](https://ko.wikipedia.org/wiki/%EC%9B%90%EC%86%8C_(%EC%88%98%ED%95%99))가 집합에 속하는지 여부를 검사하는데 사용되는 [확률적](https://ko.wikipedia.org/wiki/%ED%99%95%EB%A5%A0) [자료 구조](https://ko.wikipedia.org/wiki/%EC%9E%90%EB%A3%8C_%EA%B5%AC%EC%A1%B0)이다. 1970년 Burton Howard Bloom에 의해 고안되었다. 블룸 필터에 의해 어떤 원소가 집합에 속한다고 판단된 경우 실제로는 원소가 집합에 속하지 않는 긍정 오류가 발생하는 것이 가능하지만, 반대로 원소가 집합에 속하지 않는 것으로 판단되었는데 실제로는 원소가 집합에 속하는 부정 오류는 절대로 발생하지 않는다는 특성이 있다. 집합에 원소를 추가하는 것은 가능하나, 집합에서 원소를 삭제하는 것은 불가능하다. 집합 내 원소의 숫자가 증가할수록 긍정 오류 발생 확률도 증가한다.

       

- receiptsRoot : 영수증
- stateRoot : 계정 상태 정보 (가장 중요)
- transactionsRoot : 트랜잭션 정보(머클 루트) => 머클 패트리샤 트리
  - [참고1](https://ethereum.stackexchange.com/questions/359/where-is-the-state-data-stored)
  - [참고2](https://ethereum.stackexchange.com/questions/39915/ethereum-merkle-patricia-trie-extension-node)

---

# # 합의 알고리즘

## # Byzantine General Problem(비잔틴 장군 문제)

- 악의적인 노드가 분산 시스템에 참여한 상황을 모델링한 문제.

- 상황

  1. 300명의 병력이 있는 비잔틴성을 100명의 병력을 가진 장군 5명이 포위한 상태.

  2. 승리하기 위해 300명 이상의 병력이 공격해야함.

  3. 장군들은 연락병을 보내 소통 가능.

  4. 장군 중 배신자가 있어 서로 불신 

     ...가정부터 입력...

     

---

## # PoW(Proof of Work)

- 블록생성 시간 동안 가장 많은 해시파워를 제공한 노드가 블록을 생성 할 수 있도록 설계.

- 해시 파워를 만드는 과정은 Mining(채굴) 이라고 한다.

  - 블록체인 네트워크에 전송된 암호화 거래정보를 복호화 하여 새로운 블록을 체인에 연결하는 작업을 완료했다는 것을 증명하는데 사용되는 컴퓨팅 파워.

- PoW에서는 브랜치가 생긴 경우, 가장 긴 블록 체인이 남을 때 까지 서로 경쟁하여 이긴 브랜치가 최종적인 브랜치로 채택, 나머지는 버려짐. (즉, 1등만 채택)

- ##### 장점

  - 현재 높은 시장가치 형성하고 있는 주류 코인들이 채택.
  - 강력한 보안성.
  - 서비스 남용 쉽게 방지.

- ##### 단점

  - 높은 전력 소모, 자원 낭비.
  - 해시파워 지속적 유지.
  - 특정 마이닝 세력의 해시 독점으로 인한 생태계 교란 우려.

---

## # PoS(Proof of Stake)

- 많은 지분 소유자가 쉬운 난이도의 문제를 풀게 하는 것.

- 이자와 같은 방식으로 코인이 지급.

- ##### **장점**

  - 해시파워 많이 필요하지 않아 경제적, 친환경적.
  - 블록 생산자의 탈중앙화로 안정성 확보 가능.
  - 블록을 생성하기 위해 지분을 담보로 잡으므로 Dumping 방지 가능.

- 2011
  - 초기에 많은 지분을 보유한 사람이 블록 생성 확률 높다.
  - 불평등 문제 발생.
    - 해결책 : 보유한 코인 양과 코인 보유 일수 기반으로 블록 생성권 부여(PeerCoin에서 채택)
    - 코인이 부족해도 보유 일수가 길면 블록 생성할 확률이 높아진다.
  - 다른 문제 발생 : 적은양의 코인을 오랫동안 보관.(코인 보관 일 수 늘려 다음 블록생성 공격.)
    - 해결책 : 가중치(Weight)

- ##### PoS의 전체적인 문제점

  1. 초기 코인 분배 문제 발생 - 공정성
  2. Nothing at stake
     - 포크를 생성하여 유효한 블록을 분배
     - 유효한 블록체인을 빨리 합의하지 못하도록 방해

---

## # DPoS(위임된 지분 증명)

- 지분에 비례한 투표로 대표자를 선출
- 대표자들에게 블록 생성과 검증에 대한 권한을 부여하여 합의에 대한 권리를 위임.
- [EOS 대리 위임 21명](https://steemit.com/kr/@creamer7/eos-bp-eos-bp)
- [참고 : 비탈릭 부테린(Ethereum) vs 댄 라리먼(EOS)](http://www.hashedpost.com/2017/08/hashed-report-vs-eos.html)
  - 문제점 : 실제 환경에서 검증 미비.

- ##### State machine Replcation

  1. Safety : 오류가 발생하면 안됨.

  2. Liveness : 항상 On 유지되어야 함.

     - Fail - Over 발생할 수 있고 (고장난 경우).

       - Fail -Over Algorithm : Google paxos (고장 감내하고 무시하겠다.)

       - upgrade version >> RAFT

         > 제안자, 수용자, 수용자 역할.

     - Byzantine Falult : 악의적인 노드가 들어 올 수 있다.

       - Byzantine Falult Algorithm  : 해결하기 위해 **BFT** 계열 알고리즘 도출

         > 악의적인 노드가 있음에도 불구하고 이미 알고있는 참여자라는 조건하에 전체시스템을 안정적으로 동작하도록 하는 알고리즘.

## #PBFT(Practical Byzantine Fault Tolerance)

- 분산시스템이 약솓된 행동을 하지 않는 비잔틴 노드가 존재할 수 있는 비동기 시스템 일 때, 해당 분산시스템에 참여한 모든 노드가 성공적으로 합의를 이룰 수 있도록 개발된 합의 알고리즘.

- PoW 와 PoS의 단점인 Finality Uncertainty 과 성능 문제를 해결하는 알고리즘

- PBFT 방식은 네트워크의 모든 참가자를 미리 알고 있어야함.  

- 참가자 중 한 명이 Primary 가 되고, 자신을 포함한 모든 참가자에게 요청을 전송.

- 요청에 대한 결과를 집계한 뒤  다수의 값을 사용해 블록 확정.

- Pow 와 Pos 와 달리 의사 결정을 먼저 한 다음 블록을 생성하기 때문에 블록체인의 분기 발생X

- ##### 장점

  - Pow처럼 해답을 찾기 위한 반복적인 연산 과정X, 필요한 Resource Cost가 낮고, 훨씬 더 좋은 성능으로 동작.

- ##### 단점

  - 언제나 참가자 전원과 커뮤니케이션해야 하기 때문에 참가자가 늘어나면 통신량 증가, 처리량 저하.
  - 수 십개의 노드 한계

---

# # Transaction (트랜잭션)



## # UTXO (Unspent Transaction Output)

- 아직 쓰지 않은 잔액



---



## #SPV -> Sybil attack

![1530861501137](C:\Users\Kchaos7\AppData\Local\Temp\1530861501137.png)









---

##### #20180706.txt

```
http://192.168.0.105/
http://172.17.138.113:8080

엉클 블록과 고스트 프로토콜
1)블록생성에 성공함.
  검증에 오류가 없음
  이더리움 네트워크로 브로드캐스팅 함
  다른 채굴자가 생성한 블록에 비해 난이도 낮아서
  최종 블록체인에 등록되지 못한 블록
=> 동시에 블록이 생성되어 전파되는 경우
   난이도가 낮은 것은 블록에 등록되지 못하는
   경우 발생

- 엉클블록이 많이 발생(문제 발생)
=>트랜잭션 지연
=>컴퓨팅 파워 낭비, 긴체인 등록되지 않으면 트랜잭션
=>평균블록 생성시간이 늘어나고,난이도가 낮아지면
   보안 문제(네트워크)가, 다음 블록은 난이도 증가

--해결책
 고스트 프로토콜
 - 블록 생성시 정상 블록에 최대 2개까지 엉클
   블록을 추가하고, 보상


_엉클블럭은 처음에는 트랜잭션을 포함해서 블록생성
 ->마이너에 채택되지 않아서 엉클
 ->트랜잭션 처리되지 않고(같은 시간에 블록이 두개)

 ->정상 블록 트랜잭션 처리, 엉클 트랜잭션 처리하지
   않음(




https://steemkr.com/coinkorea/@etainclub/smart-contract-8-2




* 가스비
Gas Used:7,986,458 (99.88%)
Gas Limit:7,996,107

트랜잭션에  대한 수수료
- 기본단위 GWei - 1 ether = 1000000000 Gwei
                            10억
  
Gas Limit : 송금작업에서 소비되는 가스량
Gas Used : 지불한 가격

블록가스 총량: 한 블록에 담을 수 있는 가스 총량
         2017 - 6,700,000
         2018  -7,900,000
         최소 처리 가스 비용: 21,000

  => 최대 트랜잭션 처리 갯수?


 가스가격 * 가스한도 = 수수료

  user01 - 수수료 50
  user02 - 수수료 30
  user03 - 수수료 40
  user04 - 수수료 10
  user05 - 수수료 20


  블록 가스 최대 Limit: 100
 채굴자: 10,20,30
          50,40


 Total Difficulty: 모든 블록의 난이도 누적 합계
 - 포크의 경우 긴 체인을 결정짓는 지표

              



 sha3  - 표준

 keccak256 - sha3 의 알고리즘을 개발한 팀.
             NIST 제출

Sha3Uncles(keccak256 형식) -  현재 블록과 같은 시기에
   생성한 엉클 블록 배열의 해시값



- 데이터 존재 유무를 알기 위한 데이터 자료구조
  트랜잭션 목록, 해당 트랜잭션에서 생성된
  로그들이 중복저장 방지.
=> 저장 공간 절약


 receiptsRoot : 영수증   
 stateRoot    : 계정 상태 정보
 transactionsRoot:트랜잭션 정보(머클 루트)
=>머클 패트리샤 트리



https://ethereum.stackexchange.com/questions/359/where-is-the-state-data-stored

https://ethereum.stackexchange.com/questions/39915/ethereum-merkle-patricia-trie-extension-node

 
 
* PoS(Proof Of Stake)
- 많은 지분소유자가 쉬운 난이도의 문제 풀게 하는것
- 2011.
=> 초기에 많은 지분을 보유한 사람이 블록 생성 
   확률.
=> 불평등 문제 발생

- 해결책: 보유한 코인 양과 코인 보유 일수 기반으로
          블록 생성권 부여 (PeerCoin)
 =>코인이 부족해도 보유 일수를 길면 블록 생성할
   확률 높아짐.
 
--> 적은 양의 코인을 오래동안 보관
   (코인 일수 늘린 다음 블록생성 공격)
 
=>해결책: 가중치(Weight)
      
* PoS의 전체적인 문제점
- 일정한 지분을 가진 모든 노드에게 블록 생성권한
1) 초기 코인 분배 발생 - 공정성
2)Nothing at stake - 포크를 생성하여
  유효한 블록을 분배 방해.
  (유효한 블록체인을 빨리 합의하지 못하도록 방해)

DPOS(위임된 지분 증명)
-  지분에 비례한 투표로 대표자를 선출하고
   대표자들에게 블록 생성과 검증에 대한 권한을
  부여하여 합의에 대한 권리를 위임.

=>문제점: 실제 환경에서 검증 미비


* state machie Replcation
 1)Safety : 나쁜일이 발생하면 안되고
 2)Liveness : 항상 살아야 있어야 함

=> fail-over:  고장
  Byzantine Fault:  나쁜 노드(악의적인 행동)

fail-over 알고리즘:  구글 paxos (고장 감내)

                   업그레이드-> Raft
                 제안자, 수용자, 수용자 역할.


Byzantine Fault 알고리즘: 악의적인 노드
            - 악의적인 노드가 있음에도 불구하고
              전체 시스템에 안정적으로 동작하도록
              하는 알고리즘.


 PBFT - 하이퍼레저




 
 경과시간증명(PoET - Proof of Elapsed Time)
 - 하이퍼레저 Sawtooth
 - 하드웨어 성능보다는 CPU명령어를 사용하여
    리더 선정
 - 





 BFT 계열:

```

